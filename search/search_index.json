{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Universidade Feredal do Rio Grande do Norte (UFRN) Instituto Metr\u00f3pole Digital (IMD) Disciplina: Introdu\u00e7\u00e3o as T\u00e9cnicas de Programa\u00e7\u00e3o Integrantes do grupo: Mateus dos Santos Loiola Danilo Thiago Alves de Oliveira","title":"Home"},{"location":"#integrantes-do-grupo","text":"Mateus dos Santos Loiola Danilo Thiago Alves de Oliveira","title":"Integrantes do grupo:"},{"location":"programa/arquivo/","text":"#include stdio.h #include stdlib.h #include string.h #include math.h #include funcoes.h //funcao pixelImagem() recebe como parametro o objeto IMAGEM que foi criado //na funcao abrirArquivo() e os valores de X e Y que informa o endereco do //pixel atual que sera criado. struct Pixel* pixelImagem(Imagem* imagem, int y, int x) { return (imagem- pixels[y * imagem- larg + x]); } //Aloca espaco dinamicamente da imagem para o seu total de pixels. Imagem* novaImagem(int larg, int alt, int maxCor) { Imagem *imagem = (Imagem *) malloc(sizeof(Imagem)); imagem- pixels = (struct Pixel *) malloc(larg * alt * sizeof(struct Pixel)); imagem- larg = larg; imagem- alt = alt; imagem- maxCor = maxCor; return imagem; } //recebe por parametro ARQUIVO que eh o nome do arquivo que sera //aberto verifica se ele existe e se eh do tipo P3 cria a //estrutura da nova imagem que sera tratada e copia cada valor //rgb de toda a imagem para dentro de cada pixel, no final retorna Imagem* abrirArquivo(char *arquivo) { FILE *arq = fopen(arquivo, r ); char formato[6]; fgets(formato, 6, arq); if (arq == NULL) { printf( O arquivo nao foi encontrado ou nao existe.\\n ); return NULL; } int larg, alt, maxCor, x, y; Imagem *imagem = NULL; if (strcmp( P3\\n , formato) == 0) { fscanf(arq, %d %d \\n %d \\n , larg, alt, maxCor); printf( \\nArquivo '%s' foi carregado com sucesso.\\nTipo: %sLarg: %d\\nAlt: %d\\nMaxCor: %d\\n , arquivo, formato, larg, alt, maxCor); imagem = novaImagem(larg, alt, maxCor); for (y = 0; y alt; y++) { for (x = 0; x larg; x++) { struct Pixel *p = pixelImagem(imagem, y, x); fscanf(arq, %d %d %d , (p- r), (p- g), (p- b)); } } } else { printf( Lamentamos, atualmente so trabalhamos com PPM tipo P3. Tente Novamente!\\n ); return NULL; } fclose(arq); return imagem; } //funcao para salvar o novo arquivo void salvarArquivo(Imagem *imagem, char *nome_arquivo) { FILE *arq = fopen(strcat(nome_arquivo, .ppm ), wb ); int x, y; printf( \\nLarg:%d \\nAlt:%d\\nmaxCor:%d\\nSalvando ... , imagem- larg, imagem- alt, imagem- maxCor); fprintf(arq, P3\\n%d %d\\n%d , imagem- larg, imagem- alt, imagem- maxCor); for (y = 0; y imagem- alt; y++) { for (x = 0; x imagem- larg; x++) { struct Pixel *p = pixelImagem(imagem, y, x); fprintf(arq, \\n%d\\n%d\\n%d , p- r, p- g, p- b); } } printf( \\n ); fprintf(arq, \\n ); fclose(arq); }","title":"arquivo.c"},{"location":"programa/filtros/","text":"#include stdio.h #include stdlib.h #include string.h #include math.h #include funcoes.h //funcao para aumentar a escala da imagem, pegando um pixel e aumentando o mesmo para quatro //pixel Imagem* sharp(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y; int x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6, x7, y7, x8, y8, x9, y9; int kernel[3][3] = { { 0, -1, 0}, {-1, 5, -1}, { 0, -1, 0} }; int h = original- alt , w = original- larg; Imagem *imgBlur = novaImagem(w, h, original- maxCor); for (y = 1; y h-1; y++) { for (x = 1; x w-1; x++) { y1 = y-1; x1 = x-1; y2 = y-1; x2 = x; y3 = y-1; x3 = x+1; y4 = y; x4 = x-1; y5 = y; x5 = x; // central y6 = y; x6 = x+1; y7 = y+1; x7 = x-1; y8 = y+1; x8 = x; y9 = y+1; x9 = x+1; struct Pixel *p1 = pixelImagem(original, y1, x1); struct Pixel *p2 = pixelImagem(original, y2, x2); struct Pixel *p3 = pixelImagem(original, y3, x3); struct Pixel *p4 = pixelImagem(original, y4, x4); struct Pixel *p5 = pixelImagem(original, y5, x5); //central struct Pixel *p6 = pixelImagem(original, y6, x6); struct Pixel *p7 = pixelImagem(original, y7, x7); struct Pixel *p8 = pixelImagem(original, y8, x8); struct Pixel *p9 = pixelImagem(original, y9, x9); struct Pixel *p = pixelImagem(imgBlur, y, x); p- r = p1- r * kernel[0][0] + p2- r * kernel[0][1] + p3- r * kernel[0][2] + p4- r * kernel[1][0] + p5- r * kernel[1][1] + p6- r * kernel[1][2] + p7- r * kernel[2][0] + p8- r * kernel[2][1] + p9- r * kernel[2][2]; p- g = p1- g * kernel[0][0] + p2- g * kernel[0][1] + p3- g * kernel[0][2] + p4- g * kernel[1][0] + p5- g * kernel[1][1] + p6- g * kernel[1][2] + p7- g * kernel[2][0] + p8- g * kernel[2][1] + p9- g * kernel[2][2]; p- b = p1- b * kernel[0][0] + p2- b * kernel[0][1] + p3- b * kernel[0][2] + p4- b * kernel[1][0] + p5- b * kernel[1][1] + p6- b * kernel[1][2] + p7- b * kernel[2][0] + p8- b * kernel[2][1] + p9- b * kernel[2][2]; } } return imgBlur; } //funcao para aumentar escala da imagem, pegando um pixel e //aumentando o mesmo para quatro pixel Imagem* blur(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y; int x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6, x7, y7, x8, y8, x9, y9; double kernelBlur = 0.111111; int h = original- alt , w = original- larg; Imagem *imgBlur = novaImagem(w, h, original- maxCor); imgBlur = original; for (y = 1; y h-1; y++) { for (x = 1; x w-1; x++) { y1 = y-1; x1 = x-1; y2 = y-1; x2 = x; y3 = y-1; x3 = x+1; y4 = y; x4 = x-1; y5 = y; x5 = x; // central y6 = y; x6 = x+1; y7 = y+1; x7 = x-1; y8 = y+1; x8 = x; y9 = y+1; x9 = x+1; struct Pixel *p1 = pixelImagem(original, y1, x1); struct Pixel *p2 = pixelImagem(original, y2, x2); struct Pixel *p3 = pixelImagem(original, y3, x3); struct Pixel *p4 = pixelImagem(original, y4, x4); struct Pixel *p5 = pixelImagem(original, y5, x5); struct Pixel *p6 = pixelImagem(original, y6, x6); struct Pixel *p7 = pixelImagem(original, y7, x7); struct Pixel *p8 = pixelImagem(original, y8, x8); struct Pixel *p9 = pixelImagem(original, y9, x9); struct Pixel *p = pixelImagem(imgBlur, y, x); p- r = (int)(p1- r * kernelBlur) + (int)(p2- r * kernelBlur) + (int)(p3- r * kernelBlur) + (int)(p4- r * kernelBlur) + (int)(p5- r * kernelBlur) + (int)(p6- r * kernelBlur) + (int)(p7- r * kernelBlur) + (int)(p8- r * kernelBlur) + (int)(p9- r * kernelBlur); p- g = (int)(p1- g * kernelBlur) + (int)(p2- g * kernelBlur) + (int)(p3- g * kernelBlur) + (int)(p4- g * kernelBlur) + (int)(p5- g * kernelBlur) + (int)(p6- g * kernelBlur) + (int)(p7- g * kernelBlur) + (int)(p8- g * kernelBlur) + (int)(p9- g * kernelBlur); p- b = (int)(p1- b * kernelBlur) + (int)(p2- b * kernelBlur) + (int)(p3- b * kernelBlur) + (int)(p4- b * kernelBlur) + (int)(p5- b * kernelBlur) + (int)(p6- b * kernelBlur) + (int)(p7- b * kernelBlur) + (int)(p8- b * kernelBlur) + (int)(p9- b * kernelBlur); } } return imgBlur; } //funcao para binarizar imagem, utilizando metodo aonde compara o valor //limiar com a escala de cinza, se a escala de cinza for menor que o limiar //o valor eh 0 (preto) se for maior eh branco (255) Imagem* binarizar(Imagem *original, int limiar) { printf( Aplicando a mascara...\\n ); int x, y, gray; int h = original- alt, w = original- larg; Imagem *imgBinarizada = novaImagem(w, h, original- maxCor); for (y = 0; y h; y++) { for (x = 0; x w; x++) { struct Pixel *p1 = pixelImagem(original, y, x); struct Pixel *p2 = pixelImagem(imgBinarizada, y, x); gray = p1- r*0.3+p1- g*0.59+p1- b*0.11; if(gray limiar) { p2- r = p2- g = p2- b = 0; } else { p2- r = p2- g = p2- b = 255; } } } return imgBinarizada; } //funcao para colocar em cinza, metodo soma rgb/3 Imagem* escalaCinza(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y, gray; int h = original- alt, w = original- larg; Imagem *imgCinza = novaImagem(w, h, original- maxCor); for (y = 0; y h; y++) { for (x = 0; x w; x++) { struct Pixel *p1 = pixelImagem(original, y, x); struct Pixel *p2 = pixelImagem(imgCinza, y, x); gray = (p1- r*0.3)+(p1- g*0.59)+(p1- b*0.11); p2- r = gray; p2- g = gray; p2- b = gray; } } return imgCinza; }","title":"filtros.c"},{"location":"programa/funcoes/","text":"... #ifndef ESTRUTURA_H_INCLUDED #define ESTRUTURA_H_INCLUDED -------------------------------------------------------------------------------- //Realce do contraste por transforma\u00e7\u00e3o linear. //Estrutura de um Pixel contendo seu RGB. -------------------------------------------------------------------------------- struct Pixel { unsigned int r; unsigned int g; unsigned int b; }; -------------------------------------------------------------------------------- //Estrutura da Imagem contendo suas propriedades, especialmente o vetor dos pixels -------------------------------------------------------------------------------- typedef struct { int larg; int alt; int maxCor; struct Pixel *pixels; } Imagem; struct Pixel* pixelImagem(Imagem* imagem, int y, int x); Imagem* novaImagem(int larg, int alt, int maxCor); Imagem* sharp(Imagem *original); Imagem* blur(Imagem *original); Imagem* aumentar(Imagem *original); Imagem* reduzir(Imagem *original); Imagem* binarizar(Imagem *original, int limiar); Imagem* escalaCinza(Imagem *original); Imagem* rotacionar(Imagem *original, char* direcao); Imagem* inverterHorizontalmente(Imagem *original) ; Imagem* inverterVerticalmente(Imagem *original); Imagem* abrirArquivo(char *arquivo); void salvarArquivo(Imagem *imagem, char *nome_arquivo); #endif // ESTRUTURA_H_INCLUDED","title":"funcoes.h"},{"location":"programa/main/","text":"#include stdio.h #include stdlib.h #include string.h #include estrutura.h int main() { int limiar = 127; char opt[5]; char nome_arquivo[20]; Imagem *original, *editada; do { printf( \\n--- Selecione uma opcao abaixo ---\\n ); printf( \u2022 open - Abrir arquivo\\n ); printf( \u2022 save - Salvar arquivo\\n ); printf( \u2022 rot - Rotacinar\\n ); printf( \u2022 flp - Espelhar\\n ); printf( \u2022 gry - Tons de Cinza\\n ); printf( \u2022 blu - Bluring\\n ); printf( \u2022 sha - Sharpening\\n ); printf( \u2022 amp - Aumentar Escala\\n ); printf( \u2022 red - Reduzir Escala\\n ); printf( \u2022 thr - Thresholding (binarizacao - Preto e Branco)\\n ); printf( \u2022 exit - Sair do programa\\n ); scanf( %s , opt); opt[strcspn(opt, \\n )] = 0; if(!strcmp(opt, open )) { printf( \\n ); printf( Qual o nome do arquivo: ); scanf( %s , nome_arquivo); original = abrirArquivo(strcat(nome_arquivo, .ppm )); } else if(!strcmp(opt, save )) { printf( \\n ); if(original != NULL) { printf( Informe o nome para salvar o arquivo: ); scanf( %s , nome_arquivo); printf( \\n%d %d , editada- larg, editada- alt); salvarArquivo(original, nome_arquivo); } else { printf( Abra um arquivo primeiro.\\n ); continue; } } else if(!strcmp(opt, rot )) { printf( \\n------- ROTACIONAR -------\\n ); char direcao[4]; printf( \u2022 esq - Esquerda\\n\u2022 dir - Direita\\n ); scanf( %s , direcao); direcao[strcspn(direcao, \\n )] = 0; printf( %d %d , original- larg, original- alt); editada = rotacionar(original, direcao); original = editada; printf( %d %d , original- larg, original- alt); } else if(!strcmp(opt, flp )) { printf( \\n------- ESPELHAR -------\\n ); char sentido[4]; printf( \u2022 ver - Vertical\\n\u2022 hor - Horizontal\\n ); scanf( %s , sentido); printf( sentido: %s , sentido); sentido[strcspn(sentido, \\n )] = 0; if(!strcmp(sentido, ver )) { editada = inverterVerticalmente(original); original = editada; } else if(!strcmp(sentido, hor )) { editada = inverterHorizontalmente(original); original = editada; } else { printf( \\nOpcao invalida. ); continue; } } else if(!strcmp(opt, gry )) { printf( \\n------- TONS DE CINZA -------\\n ); editada = escalaCinza(original); original = editada; } else if(!strcmp(opt, blu )) { printf( \\n------- BLURING -------\\n ); editada = blur(original); original = editada; } else if(!strcmp(opt, sha )) { printf( \\n------- SHARPENING -------\\n ); editada = sharp(original); original = editada; } else if(!strcmp(opt, amp )) { printf( \\n------- AUMENTAR ESCALA -------\\n ); editada = aumentar(original); original = editada; } else if(!strcmp(opt, red )) { printf( \\n------- REDUZIR ESCALA -------\\n ); editada = reduzir(original); original = editada; } else if(!strcmp(opt, thr )) { printf( \\n------- THRESHOLDING -------\\n ); int limiar = 127; do { printf( \\nInforme o valor da limiar desejado (Ex: 127): ); scanf( %d , limiar); } while (limiar 0 255 limiar); editada = binarizar(original, limiar); original = editada; } else { printf( \\nOpcao invalida!\\n ); } } while (strcmp(opt, exit )); return 1; }","title":"main"},{"location":"programa/rotacionar/","text":"#include stdio.h #include stdlib.h #include string.h #include math.h #include funcoes.h //funcao para rotacionar a direita e a esquerda Imagem* rotacionar(Imagem *original, char* direcao) { printf( Aplicando a mascara...\\n ); int x, y, i, j; int h = original- alt, w = original- larg; Imagem *imgRotacionada = novaImagem(h, w, original- maxCor); for (x = 0; x w; x++) { for (y = 0; y h; y++) { struct Pixel *p1 = pixelImagem(original, y, x); if(!strcmp(direcao, dir )) { i = x; j = h-y-1; } else { i = w-x-1; j = y; } struct Pixel *p2 = pixelImagem(imgRotacionada, i, j); p2- r = p1- r; p2- g = p1- g; p2- b = p1- b; } } return imgRotacionada; } //funcao para inverter horizontalmente Imagem* inverterHorizontalmente(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y; int h = original- alt, w = original- larg; Imagem *imgInvertidaHorizontal = novaImagem(w, h, original- maxCor); for (y = h-1; y = 0; y--) { for (x = 0; x w; x++) { struct Pixel *p1 = pixelImagem(original, y, x); struct Pixel *p2 = pixelImagem(imgInvertidaHorizontal, h-y-1, x); p2- r = p1- r; p2- g = p1- g; p2- b = p1- b; } } return imgInvertidaHorizontal; } //funcao para inverter verticalmente Imagem* inverterVerticalmente(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y; int h = original- alt, w = original- larg; Imagem *imgInvertidaVertical = novaImagem(w, h, original- maxCor); for (x = 0; x w; x++) { for (y = 0; y h; y++) { struct Pixel *p1 = pixelImagem(original, y, x); struct Pixel *p2 = pixelImagem(imgInvertidaVertical, y, w-x-1); p2- r = p1- r; p2- g = p1- g; p2- b = p1- b; } } return imgInvertidaVertical; }","title":"rotacionar.c"},{"location":"programa/tamanho/","text":"#include stdio.h #include stdlib.h #include string.h #include math.h #include funcoes.h //funcao para aumentar escala da imagem, pegando um pixel e //aumentando o mesmo para quatro pixel Imagem* aumentar(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y, x1, y1, x2, y2, x3, y3, x4, y4; int h = original- alt , w = original- larg; Imagem *imgBig = novaImagem(w*2, h*2, original- maxCor); for (y = 0; y h; y++) { for (x = 0; x w; x++) { struct Pixel *p1 = pixelImagem(original, y, x); y1 = y*2; x1 = x*2; y2 = y*2+1; x2 = x*2; y3 = y*2; x3 = x*2+1; y4 = y*2+1; x4 = x*2+1; struct Pixel *p2_1 = pixelImagem(imgBig, y1, x1); struct Pixel *p2_2 = pixelImagem(imgBig, y2, x2); struct Pixel *p2_3 = pixelImagem(imgBig, y3, x3); struct Pixel *p2_4 = pixelImagem(imgBig, y4, x4); p2_1- r = p2_2- r = p2_3- r = p2_4- r = p1- r; p2_1- g = p2_2- g = p2_3- g = p2_4- g = p1- g; p2_1- b = p2_2- b = p2_3- b = p2_4- b = p1- b; } } return imgBig; } //funcao para aumentar escala da imagem, pegando um pixel e //aumentando o mesmo para quatro pixel Imagem* reduzir(Imagem *original) { printf( Aplicando a mascara...\\n ); int x, y, i=0, j=0; int h = original- alt , w = original- larg; int width = ceil((float)w/2), height = ceil((float)h/2); Imagem *imgSmall = novaImagem(width, height, original- maxCor); for (y = 0; y h; y+=2) { i = 0; for (x = 0; x w; x+=2) { struct Pixel *p1 = pixelImagem(original, y, x); struct Pixel *p2 = pixelImagem(imgSmall, j, i); p2- r = p1- r; p2- g = p1- g; p2- b = p1- b; i+=1; } j+=1; } return imgSmall; }","title":"tamanho.c"}]}